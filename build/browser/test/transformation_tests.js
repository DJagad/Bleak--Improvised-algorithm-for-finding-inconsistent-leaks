import { equal as assertEqual, notEqual as assertNotEqual } from 'assert';
import { exposeClosureState, injectIntoHead, parseHTML } from '../src/lib/transformations';
import { DEFAULT_AGENT_URL, DEFAULT_BABEL_POLYFILL_URL } from '../src/lib/mitmproxy_interceptor';
import { readFileSync } from 'fs';
var AGENT_SOURCE = readFileSync(require.resolve('../src/lib/bleak_agent'), "utf8");
/**
 * An XMLHttpRequest mock, passed to the BLeak agent so it can support programs with eval.
 * Mirrors the behavior of the proxy when the /eval URL is requested.
 */
var XHRShim = /** @class */ (function () {
    function XHRShim() {
        this.responseText = null;
    }
    XHRShim.prototype.open = function () { };
    XHRShim.prototype.setRequestHeader = function () { };
    XHRShim.prototype.send = function (data) {
        var d = JSON.parse(data);
        this.responseText = exposeClosureState("eval-" + Math.random() + ".js", d.source, DEFAULT_AGENT_URL, DEFAULT_BABEL_POLYFILL_URL, d.scope);
    };
    return XHRShim;
}());
describe('Transformations', function () {
    describe('injectIntoHead', function () {
        var headTagTypes = [
            ["<head>", "</head>", 'is in lowercase'],
            ["<HEAD>", "</HEAD>", 'is in uppercase'],
            ["<heAd>", "</heAd>", 'is in a mix of lower and uppercase'],
            ["", "", 'is missing']
        ];
        var rawInjection = "<script>hello</script>";
        var injection = parseHTML(rawInjection);
        headTagTypes.forEach(function (headTag) {
            it("should work when the head tag " + headTag[2], function () {
                var source = "<!DOCTYPE html><html>" + headTag[0] + headTag[1] + "</html>";
                var output = "<!DOCTYPE html><html>" + headTag[0] + rawInjection + headTag[1] + "</html>";
                assertEqual(injectIntoHead("test.html", source, injection), output);
            });
        });
    });
    describe("Inline JavaScript", function () {
        it("should rewrite inline JavaScript", function () {
            var source = "<html><head><script type=\"text/javascript\">\n      function foo() {\n\n      }\n      </script></head></html>";
            var expected = "<html><head><script type=\"text/javascript\">NO</script></head></html>";
            assertEqual(injectIntoHead("test.html", source, [], function () { return "NO"; }), expected);
        });
    });
    describe('exposeClosureState', function () {
        function instrumentModule(source) {
            var newSource = exposeClosureState("main.js", "(function(exports) { " + source + " })(exports);");
            // Super basic CommonJS shim.
            var exp = {};
            new Function('exports', 'XMLHttpRequest', AGENT_SOURCE + "\n" + newSource)(exp, XHRShim);
            return exp;
        }
        it('works with function declarations', function () {
            var module = instrumentModule("\n        var a = 'hello';\n        var b = 'hello';\n        function decl(){ if (false) { decl(); } return a; }\n        exports.decl = decl;\n      ");
            assertEqual(module.decl.__scope__['a'], 'hello');
            assertEqual(module.decl.__scope__['decl'], module.decl);
            // b isn't closed over.
            assertEqual(module.decl.__scope__['b'], undefined);
            module.decl.__scope__['a'] = 'no';
            assertEqual(module.decl.__scope__['a'], 'no');
            var arr = [1, 2, 3];
            module.decl.__scope__['a'] = arr;
            assertEqual(module.decl(), arr);
        });
        it('works with function expressions', function () {
            var module = instrumentModule("\n        var a = 'hello';\n        exports.decl = function(){ if (exports) {} return a; };\n      ");
            assertEqual(module.decl.__scope__['a'], 'hello');
            assertEqual(module.decl.__scope__['exports'].decl, module.decl);
        });
        it("works with named function expressions", function () {
            var module = instrumentModule("\n        var a = 'hello';\n        exports.decl = function decl2(){ return a; };\n      ");
            assertEqual(module.decl.__scope__['a'], 'hello');
        });
        it("works with multiple functions in the same block and multiple variables", function () {
            var module = instrumentModule("\n        var a='hello';\n        var b=3;\n        exports.decl=function(){ return a + b; };\n        exports.decl2=function(){ return a + b; };\n      ");
            assertEqual(module.decl.__scope__['a'], 'hello');
            assertEqual(module.decl2.__scope__['a'], 'hello');
            assertEqual(module.decl.__scope__['b'], 3);
            assertEqual(module.decl.__scope__['b'], 3);
        });
        it("works with nested functions", function () {
            var module = instrumentModule("\n        var a = 'hello';\n        function decl(){ return a; }\n        function notDecl(){\n          var decl = function decl(){};\n          return decl;\n        }\n        exports.decl = decl;\n        exports.notDecl = notDecl;\n      ");
            assertEqual(module.decl.__scope__['a'], 'hello');
            assertEqual(module.notDecl.__scope__['a'], 'hello');
            assertEqual(module.notDecl().__scope__['a'], 'hello');
        });
        it("works with nested function declarations", function () {
            var module = instrumentModule("\n        var a = 'hello';\n        function decl(){ return a; }\n        function notDecl(){\n          function decl(){}\n          return decl;\n        }\n        exports.decl = decl;\n        exports.notDecl = notDecl;\n      ");
            assertEqual(module.decl.__scope__['a'], 'hello');
            assertEqual(module.notDecl.__scope__['a'], 'hello');
            assertEqual(module.notDecl().__scope__['a'], 'hello');
        });
        it("works with functions in a list", function () {
            var module = instrumentModule("\n        var a = 'hello';\n        exports.obj = {\n          decl: function() { return a; },\n          decl2: function() {\n            return 3\n          }\n        };\n      ");
            assertEqual(module.obj.decl.__scope__['a'], 'hello');
            assertEqual(module.obj.decl2.__scope__['a'], 'hello');
        });
        it("works with initializer lists in for loops", function () {
            var module = instrumentModule("\n        exports.obj = {\n          decl: function(a, b) {\n            for (var i = 0, j = 0; i < b.length; i++) {\n              j++;\n              a += j;\n            }\n            return a;\n          }\n        };\n      ");
            assertEqual(module.obj.decl(0, [0, 1, 2]), 6);
        });
        it("works with initializers in for of loops", function () {
            var module = instrumentModule("\n        exports.obj = {\n          decl: function(a, b) {\n            for (var prop of b) {\n              if (b.hasOwnProperty(prop)) {\n                a += parseInt(prop, 10);\n              }\n            }\n            // Make sure prop doesn't escape.\n            return function() {\n              return [prop, a];\n            };\n          }\n        };\n      ");
            assertEqual(module.obj.decl(0, [0, 1, 2])()[1], 3);
        });
        it("works with initializers in for in loops", function () {
            var module = instrumentModule("\n        exports.b = [0,1,2];\n        exports.obj = {\n          decl: function(a) {\n            for (var prop in exports.b) a += prop;\n            prop = \"hello\";\n            // Make sure prop escapes.\n            return function() {\n              return prop;\n            };\n          }\n        };\n      ");
            assertEqual(module.obj.decl("")(), "hello");
        });
        it("works with catch clauses", function () {
            var module = instrumentModule("\n        var err, e;\n        exports.obj = {\n          decl: function() {\n            try { throw new Error(\"Hello\"); } catch (e) { err = e; }\n          }\n        };\n      ");
            module.obj.decl();
            assertEqual(module.obj.decl.__scope__['err'].message, "Hello");
        });
        it("works with object literals", function () {
            var module = instrumentModule("\n        var e = 5;\n        exports.obj = {\n          decl: function() {\n            return { e: e };\n          }\n        };\n      ");
            assertEqual(module.obj.decl().e, 5);
        });
        it("works with computed properties", function () {
            var module = instrumentModule("\n        var e = 0;\n        exports.obj = {\n          decl: function() {\n            return arguments[e];\n          }\n        };\n      ");
            assertEqual(module.obj.decl(100), 100);
        });
        it("works with named function expressions", function () {
            var module = instrumentModule("\n        var e = 0;\n        exports.obj = {\n          decl: function() {\n            return function e(i) {\n              return i === 0 ? 5 : e(i - 1);\n            };\n          }\n        };\n      ");
            assertEqual(module.obj.decl()(3), 5);
        });
        it("does not change value of this", function () {
            var module = instrumentModule("\n        var e = function() { return this; };\n        exports.obj = {\n          decl: function() {\n            return e();\n          }\n        };\n      ");
            assertEqual(module.obj.decl(), global);
        });
        it("keeps strict mode declaration", function () {
            var module = instrumentModule("\n        var e = function() { \"use strict\"; return this; };\n        exports.obj = {\n          decl: function() {\n            return e();\n          }\n        };\n      ");
            assertEqual(module.obj.decl(), undefined);
        });
        it("updates arguments", function () {
            var module = instrumentModule("\n        exports.obj = {\n          decl: function(e) {\n            e = 4;\n            return arguments[0];\n          }\n        };\n      ");
            assertEqual(module.obj.decl(100), 4);
        });
        it("works on functions illegally defined in blocks", function () {
            var module = instrumentModule("\n        exports.obj = {\n          decl: function() {\n            if (1) {\n              function Z() {\n                var a = 4;\n                return function() { return a; };\n              }\n              return Z;\n            }\n          }\n        };\n      ");
            assertEqual(module.obj.decl()()(), 4);
        });
        it("works on functions illegally defined in switch cases", function () {
            var module = instrumentModule("\n        exports.obj = {\n          decl: function(s) {\n            switch (s) {\n              case 1:\n                function Z() {\n                  var a = 4;\n                  return function() { return a; };\n                }\n                return Z;\n            }\n          }\n        };\n      ");
            assertEqual(module.obj.decl(1)()(), 4);
        });
        it("works on function expressions with names", function () {
            var module = instrumentModule("\n        exports.obj = function s() {\n          s = 4;\n          return s;\n        };\n      ");
            assertEqual(module.obj(), module.obj);
        });
        it("makes proxy objects equal to original objects", function () {
            var module = instrumentModule("\n        global.a = {};\n        exports.obj = function () {\n          return a;\n        };\n        exports.cmp = function(b) {\n          return a === b;\n        };\n      ");
            var a = module.obj();
            global.$$$INSTRUMENT_PATHS$$$([{
                    id: 1,
                    isGrowing: true,
                    indexOrName: "a",
                    type: 1 /* PROPERTY */,
                    children: []
                }]);
            assertNotEqual(module.obj(), a, "Proxy for global variable 'a' is properly installed");
            assertEqual(module.cmp(a), true, "a === Proxy(a)");
            assertEqual(module.cmp(module.obj()), true, "Proxy(a) === Proxy(a)");
        });
        it("works with null array entry", function () {
            var module = instrumentModule("exports.obj = [,1,2];");
            assertEqual(module.obj[0], null);
        });
        it("works with computed properties", function () {
            var module = instrumentModule("\n        var a = \"hello\";\n        var obj = { hello: 3 };\n        exports.fcn = function() {\n          return obj[a];\n        };");
            assertEqual(module.fcn(), 3);
            assertEqual(module.fcn.__scope__.a, "hello");
        });
        it("works with arguments that do not escape", function () {
            var module = instrumentModule("\n        exports.fcn = function(a) {\n          return a\n        };");
            assertEqual(module.fcn(3), 3);
        });
        it("works with arguments that escape", function () {
            var module = instrumentModule("\n        exports.fcn = function(a) {\n          return function() { return a; };\n        };");
            assertEqual(module.fcn(3)(), 3);
        });
        it("moves all heap objects when eval is used", function () {
            var module = instrumentModule("\n        var secret = 3;\n        exports.fcn = function(a) {\n          return eval(a);\n        };");
            assertEqual(module.fcn("secret"), 3);
            assertEqual(module.fcn.__scope__.secret, 3);
            assertEqual(module.fcn("a"), "a");
        });
        it("appropriately overwrites variables when eval is used", function () {
            var module = instrumentModule("\n        global.secret = 3;\n        exports.fcn = function(a) {\n          return eval(a);\n        };");
            assertEqual(module.fcn.__scope__.secret, 3);
            assertEqual(global.secret, 3);
            global.secret = 4;
            assertEqual(module.fcn.__scope__.secret, 4);
            module.fcn("secret = 6");
            assertEqual(module.fcn.__scope__.secret, 6);
            assertEqual(global.secret, 6);
        });
        it("works with with()", function () {
            var module = instrumentModule("\n        var l = 3;\n        var o = { l: 5 };\n        exports.fcn = function() {\n          with(o) {\n            return l;\n          }\n        };\n        exports.assign = function(v) {\n          with(o) { l = v; return l; }\n        };");
            assertEqual(module.fcn(), 5);
            assertEqual(module.assign(7), 7);
            assertEqual(module.fcn(), 7);
        });
        // instrument a global variable and get stack traces
        // with() with undefined / null / zeroish values.
        // growing paths: set up such that it has two separate custom setters!
        // growing window?
        // cycle of growing objects??
        // getters/setters
        // template literal
        // arrow functions, with `this` as the leaking object. arrow has only ref.
        // multiple object patterns that reference each other, e.g.:
        // var {a, b, c} = foo, {d=a} = bar;
        // a leak in a getter, e.g. { get foo() { var a;  return function() { } }}
        // or actually more like { get foo() { bar[random] = 3; }}
        // ==> Shows up as `get foo`!! Instrument both `foo` and `get foo`.
    });
    // NEED A SWITCH CASE VERSION where it's not within a block!!!
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmb3JtYXRpb25fdGVzdHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi90ZXN0L3RyYW5zZm9ybWF0aW9uX3Rlc3RzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxLQUFLLElBQUksV0FBVyxFQUFFLFFBQVEsSUFBSSxjQUFjLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDeEUsT0FBTyxFQUFDLGtCQUFrQixFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUN6RixPQUFPLEVBQUMsaUJBQWlCLEVBQUUsMEJBQTBCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUMvRixPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sSUFBSSxDQUFDO0FBRWhDLElBQU0sWUFBWSxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFFckY7OztHQUdHO0FBQ0g7SUFBQTtRQUNTLGlCQUFZLEdBQVcsSUFBSSxDQUFDO0lBT3JDLENBQUM7SUFOUSxzQkFBSSxHQUFYLGNBQWUsQ0FBQztJQUNULGtDQUFnQixHQUF2QixjQUEyQixDQUFDO0lBQ3JCLHNCQUFJLEdBQVgsVUFBWSxJQUFZO1FBQ3RCLElBQU0sQ0FBQyxHQUFzQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlELElBQUksQ0FBQyxZQUFZLEdBQUcsa0JBQWtCLENBQUMsVUFBUSxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQUssRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLGlCQUFpQixFQUFFLDBCQUEwQixFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2SSxDQUFDO0lBQ0gsY0FBQztBQUFELENBQUMsQUFSRCxJQVFDO0FBRUQsUUFBUSxDQUFDLGlCQUFpQixFQUFFO0lBQzFCLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRTtRQUN6QixJQUFN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QUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDeEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsbUJBQW1CLEVBQUU7WUFDdEIsSUFBTSxNQUFNLEdBQUcsZ0JBQWdCLENBQTRDLHNQQVV0RSxDQUFDLENBQUM7WUFDUCxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzdCLFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2pDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDL0IsQ0FBQyxDQUFDLENBQUM7UUFFSCxvREFBb0Q7UUFDcEQsaURBQWlEO1FBRWpELHNFQUFzRTtRQUV0RSxrQkFBa0I7UUFFbEIsNkJBQTZCO1FBRTdCLGtCQUFrQjtRQUVsQixtQkFBbUI7UUFFbkIsMEVBQTBFO1FBQzFFLDREQUE0RDtRQUM1RCxvQ0FBb0M7UUFFcEMsMEVBQTBFO1FBQzFFLDBEQUEwRDtRQUMxRCxtRUFBbUU7SUFDckUsQ0FBQyxDQUFDLENBQUM7SUFDSCw4REFBOEQ7QUFDaEUsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2VxdWFsIGFzIGFzc2VydEVxdWFsLCBub3RFcXVhbCBhcyBhc3NlcnROb3RFcXVhbH0gZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7ZXhwb3NlQ2xvc3VyZVN0YXRlLCBpbmplY3RJbnRvSGVhZCwgcGFyc2VIVE1MfSBmcm9tICcuLi9zcmMvbGliL3RyYW5zZm9ybWF0aW9ucyc7XG5pbXBvcnQge0RFRkFVTFRfQUdFTlRfVVJMLCBERUZBVUxUX0JBQkVMX1BPTFlGSUxMX1VSTH0gZnJvbSAnLi4vc3JjL2xpYi9taXRtcHJveHlfaW50ZXJjZXB0b3InO1xuaW1wb3J0IHtyZWFkRmlsZVN5bmN9IGZyb20gJ2ZzJztcblxuY29uc3QgQUdFTlRfU09VUkNFID0gcmVhZEZpbGVTeW5jKHJlcXVpcmUucmVzb2x2ZSgnLi4vc3JjL2xpYi9ibGVha19hZ2VudCcpLCBcInV0ZjhcIik7XG5cbi8qKlxuICogQW4gWE1MSHR0cFJlcXVlc3QgbW9jaywgcGFzc2VkIHRvIHRoZSBCTGVhayBhZ2VudCBzbyBpdCBjYW4gc3VwcG9ydCBwcm9ncmFtcyB3aXRoIGV2YWwuXG4gKiBNaXJyb3JzIHRoZSBiZWhhdmlvciBvZiB0aGUgcHJveHkgd2hlbiB0aGUgL2V2YWwgVVJMIGlzIHJlcXVlc3RlZC5cbiAqL1xuY2xhc3MgWEhSU2hpbSB7XG4gIHB1YmxpYyByZXNwb25zZVRleHQ6IHN0cmluZyA9IG51bGw7XG4gIHB1YmxpYyBvcGVuKCkge31cbiAgcHVibGljIHNldFJlcXVlc3RIZWFkZXIoKSB7fVxuICBwdWJsaWMgc2VuZChkYXRhOiBzdHJpbmcpIHtcbiAgICBjb25zdCBkOiB7IHNjb3BlOiBzdHJpbmcsIHNvdXJjZTogc3RyaW5nIH0gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gZXhwb3NlQ2xvc3VyZVN0YXRlKGBldmFsLSR7TWF0aC5yYW5kb20oKX0uanNgLCBkLnNvdXJjZSwgREVGQVVMVF9BR0VOVF9VUkwsIERFRkFVTFRfQkFCRUxfUE9MWUZJTExfVVJMLCBkLnNjb3BlKTtcbiAgfVxufVxuXG5kZXNjcmliZSgnVHJhbnNmb3JtYXRpb25zJywgZnVuY3Rpb24oKSB7XG4gIGRlc2NyaWJlKCdpbmplY3RJbnRvSGVhZCcsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGhlYWRUYWdUeXBlcyA9IFtcbiAgICAgIFtgPGhlYWQ+YCwgYDwvaGVhZD5gLCAnaXMgaW4gbG93ZXJjYXNlJ10sXG4gICAgICBbYDxIRUFEPmAsIGA8L0hFQUQ+YCwgJ2lzIGluIHVwcGVyY2FzZSddLFxuICAgICAgW2A8aGVBZD5gLCBgPC9oZUFkPmAsICdpcyBpbiBhIG1peCBvZiBsb3dlciBhbmQgdXBwZXJjYXNlJ10sXG4gICAgICBbYGAsIGBgLCAnaXMgbWlzc2luZyddXG4gICAgXTtcbiAgICBjb25zdCByYXdJbmplY3Rpb24gPSBgPHNjcmlwdD5oZWxsbzwvc2NyaXB0PmA7XG4gICAgY29uc3QgaW5qZWN0aW9uID0gcGFyc2VIVE1MKHJhd0luamVjdGlvbik7XG4gICAgaGVhZFRhZ1R5cGVzLmZvckVhY2goKGhlYWRUYWcpID0+IHtcbiAgICAgIGl0KGBzaG91bGQgd29yayB3aGVuIHRoZSBoZWFkIHRhZyAke2hlYWRUYWdbMl19YCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGA8IURPQ1RZUEUgaHRtbD48aHRtbD4ke2hlYWRUYWdbMF19JHtoZWFkVGFnWzFdfTwvaHRtbD5gO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBgPCFET0NUWVBFIGh0bWw+PGh0bWw+JHtoZWFkVGFnWzBdfSR7cmF3SW5qZWN0aW9ufSR7aGVhZFRhZ1sxXX08L2h0bWw+YDtcbiAgICAgICAgYXNzZXJ0RXF1YWwoaW5qZWN0SW50b0hlYWQoXCJ0ZXN0Lmh0bWxcIiwgc291cmNlLCBpbmplY3Rpb24pLCBvdXRwdXQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKGBJbmxpbmUgSmF2YVNjcmlwdGAsIGZ1bmN0aW9uKCkge1xuICAgIGl0KGBzaG91bGQgcmV3cml0ZSBpbmxpbmUgSmF2YVNjcmlwdGAsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgc291cmNlID0gYDxodG1sPjxoZWFkPjxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPlxuICAgICAgZnVuY3Rpb24gZm9vKCkge1xuXG4gICAgICB9XG4gICAgICA8L3NjcmlwdD48L2hlYWQ+PC9odG1sPmA7XG4gICAgICBjb25zdCBleHBlY3RlZCA9IGA8aHRtbD48aGVhZD48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5OTzwvc2NyaXB0PjwvaGVhZD48L2h0bWw+YDtcbiAgICAgIGFzc2VydEVxdWFsKGluamVjdEludG9IZWFkKFwidGVzdC5odG1sXCIsIHNvdXJjZSwgW10sICgpID0+IFwiTk9cIiksIGV4cGVjdGVkKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2V4cG9zZUNsb3N1cmVTdGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGluc3RydW1lbnRNb2R1bGU8VD4oc291cmNlOiBzdHJpbmcpOiBUIHtcbiAgICAgIGNvbnN0IG5ld1NvdXJjZSA9IGV4cG9zZUNsb3N1cmVTdGF0ZShcIm1haW4uanNcIiwgYChmdW5jdGlvbihleHBvcnRzKSB7ICR7c291cmNlfSB9KShleHBvcnRzKTtgKTtcbiAgICAgIC8vIFN1cGVyIGJhc2ljIENvbW1vbkpTIHNoaW0uXG4gICAgICBjb25zdCBleHA6IGFueSA9IHt9O1xuICAgICAgbmV3IEZ1bmN0aW9uKCdleHBvcnRzJywgJ1hNTEh0dHBSZXF1ZXN0JywgQUdFTlRfU09VUkNFICsgXCJcXG5cIiArIG5ld1NvdXJjZSkoZXhwLCBYSFJTaGltKTtcbiAgICAgIHJldHVybiBleHA7XG4gICAgfVxuXG4gICAgaXQoJ3dvcmtzIHdpdGggZnVuY3Rpb24gZGVjbGFyYXRpb25zJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtkZWNsOiBGdW5jdGlvbn0+KGBcbiAgICAgICAgdmFyIGEgPSAnaGVsbG8nO1xuICAgICAgICB2YXIgYiA9ICdoZWxsbyc7XG4gICAgICAgIGZ1bmN0aW9uIGRlY2woKXsgaWYgKGZhbHNlKSB7IGRlY2woKTsgfSByZXR1cm4gYTsgfVxuICAgICAgICBleHBvcnRzLmRlY2wgPSBkZWNsO1xuICAgICAgYCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZGVjbC5fX3Njb3BlX19bJ2EnXSwgJ2hlbGxvJyk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZGVjbC5fX3Njb3BlX19bJ2RlY2wnXSwgbW9kdWxlLmRlY2wpO1xuICAgICAgLy8gYiBpc24ndCBjbG9zZWQgb3Zlci5cbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5kZWNsLl9fc2NvcGVfX1snYiddLCB1bmRlZmluZWQpO1xuICAgICAgbW9kdWxlLmRlY2wuX19zY29wZV9fWydhJ10gPSAnbm8nO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLmRlY2wuX19zY29wZV9fWydhJ10sICdubycpO1xuICAgICAgY29uc3QgYXJyID0gWzEsMiwzXTtcbiAgICAgIG1vZHVsZS5kZWNsLl9fc2NvcGVfX1snYSddID0gYXJyO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLmRlY2woKSwgYXJyKTtcbiAgICB9KTtcblxuICAgIGl0KCd3b3JrcyB3aXRoIGZ1bmN0aW9uIGV4cHJlc3Npb25zJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtkZWNsOiBGdW5jdGlvbn0+KGBcbiAgICAgICAgdmFyIGEgPSAnaGVsbG8nO1xuICAgICAgICBleHBvcnRzLmRlY2wgPSBmdW5jdGlvbigpeyBpZiAoZXhwb3J0cykge30gcmV0dXJuIGE7IH07XG4gICAgICBgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5kZWNsLl9fc2NvcGVfX1snYSddLCAnaGVsbG8nKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5kZWNsLl9fc2NvcGVfX1snZXhwb3J0cyddLmRlY2wsIG1vZHVsZS5kZWNsKTtcbiAgICB9KTtcblxuICAgIGl0KGB3b3JrcyB3aXRoIG5hbWVkIGZ1bmN0aW9uIGV4cHJlc3Npb25zYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtkZWNsOiBGdW5jdGlvbn0+KGBcbiAgICAgICAgdmFyIGEgPSAnaGVsbG8nO1xuICAgICAgICBleHBvcnRzLmRlY2wgPSBmdW5jdGlvbiBkZWNsMigpeyByZXR1cm4gYTsgfTtcbiAgICAgIGApO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLmRlY2wuX19zY29wZV9fWydhJ10sICdoZWxsbycpO1xuICAgIH0pO1xuXG4gICAgaXQoYHdvcmtzIHdpdGggbXVsdGlwbGUgZnVuY3Rpb25zIGluIHRoZSBzYW1lIGJsb2NrIGFuZCBtdWx0aXBsZSB2YXJpYWJsZXNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e2RlY2w6IEZ1bmN0aW9uLCBkZWNsMjogRnVuY3Rpb259PihgXG4gICAgICAgIHZhciBhPSdoZWxsbyc7XG4gICAgICAgIHZhciBiPTM7XG4gICAgICAgIGV4cG9ydHMuZGVjbD1mdW5jdGlvbigpeyByZXR1cm4gYSArIGI7IH07XG4gICAgICAgIGV4cG9ydHMuZGVjbDI9ZnVuY3Rpb24oKXsgcmV0dXJuIGEgKyBiOyB9O1xuICAgICAgYCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZGVjbC5fX3Njb3BlX19bJ2EnXSwgJ2hlbGxvJyk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZGVjbDIuX19zY29wZV9fWydhJ10sICdoZWxsbycpO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLmRlY2wuX19zY29wZV9fWydiJ10sIDMpO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLmRlY2wuX19zY29wZV9fWydiJ10sIDMpO1xuICAgIH0pO1xuXG4gICAgaXQoYHdvcmtzIHdpdGggbmVzdGVkIGZ1bmN0aW9uc2AsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdHJ1bWVudE1vZHVsZTx7ZGVjbDogRnVuY3Rpb24sIG5vdERlY2w6IEZ1bmN0aW9ufT4oYFxuICAgICAgICB2YXIgYSA9ICdoZWxsbyc7XG4gICAgICAgIGZ1bmN0aW9uIGRlY2woKXsgcmV0dXJuIGE7IH1cbiAgICAgICAgZnVuY3Rpb24gbm90RGVjbCgpe1xuICAgICAgICAgIHZhciBkZWNsID0gZnVuY3Rpb24gZGVjbCgpe307XG4gICAgICAgICAgcmV0dXJuIGRlY2w7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5kZWNsID0gZGVjbDtcbiAgICAgICAgZXhwb3J0cy5ub3REZWNsID0gbm90RGVjbDtcbiAgICAgIGApO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLmRlY2wuX19zY29wZV9fWydhJ10sICdoZWxsbycpO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLm5vdERlY2wuX19zY29wZV9fWydhJ10sICdoZWxsbycpO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLm5vdERlY2woKS5fX3Njb3BlX19bJ2EnXSwgJ2hlbGxvJyk7XG4gICAgfSk7XG5cbiAgICBpdChgd29ya3Mgd2l0aCBuZXN0ZWQgZnVuY3Rpb24gZGVjbGFyYXRpb25zYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtkZWNsOiBGdW5jdGlvbiwgbm90RGVjbDogRnVuY3Rpb259PihgXG4gICAgICAgIHZhciBhID0gJ2hlbGxvJztcbiAgICAgICAgZnVuY3Rpb24gZGVjbCgpeyByZXR1cm4gYTsgfVxuICAgICAgICBmdW5jdGlvbiBub3REZWNsKCl7XG4gICAgICAgICAgZnVuY3Rpb24gZGVjbCgpe31cbiAgICAgICAgICByZXR1cm4gZGVjbDtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLmRlY2wgPSBkZWNsO1xuICAgICAgICBleHBvcnRzLm5vdERlY2wgPSBub3REZWNsO1xuICAgICAgYClcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5kZWNsLl9fc2NvcGVfX1snYSddLCAnaGVsbG8nKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5ub3REZWNsLl9fc2NvcGVfX1snYSddLCAnaGVsbG8nKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5ub3REZWNsKCkuX19zY29wZV9fWydhJ10sICdoZWxsbycpO1xuICAgIH0pO1xuXG4gICAgaXQoYHdvcmtzIHdpdGggZnVuY3Rpb25zIGluIGEgbGlzdGAsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdHJ1bWVudE1vZHVsZTx7b2JqOiB7ZGVjbDogRnVuY3Rpb24sIGRlY2wyOiBGdW5jdGlvbn19PihgXG4gICAgICAgIHZhciBhID0gJ2hlbGxvJztcbiAgICAgICAgZXhwb3J0cy5vYmogPSB7XG4gICAgICAgICAgZGVjbDogZnVuY3Rpb24oKSB7IHJldHVybiBhOyB9LFxuICAgICAgICAgIGRlY2wyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgYCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUub2JqLmRlY2wuX19zY29wZV9fWydhJ10sICdoZWxsbycpO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLm9iai5kZWNsMi5fX3Njb3BlX19bJ2EnXSwgJ2hlbGxvJyk7XG4gICAgfSk7XG5cbiAgICBpdChgd29ya3Mgd2l0aCBpbml0aWFsaXplciBsaXN0cyBpbiBmb3IgbG9vcHNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e29iajoge2RlY2w6IEZ1bmN0aW9ufX0+KGBcbiAgICAgICAgZXhwb3J0cy5vYmogPSB7XG4gICAgICAgICAgZGVjbDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgIGEgKz0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIGApO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLm9iai5kZWNsKDAsIFswLDEsMl0pLCA2KTtcbiAgICB9KTtcblxuICAgIGl0KGB3b3JrcyB3aXRoIGluaXRpYWxpemVycyBpbiBmb3Igb2YgbG9vcHNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e29iajoge2RlY2w6IEZ1bmN0aW9ufX0+KGBcbiAgICAgICAgZXhwb3J0cy5vYmogPSB7XG4gICAgICAgICAgZGVjbDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBvZiBiKSB7XG4gICAgICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgYSArPSBwYXJzZUludChwcm9wLCAxMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBwcm9wIGRvZXNuJ3QgZXNjYXBlLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW3Byb3AsIGFdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5vYmouZGVjbCgwLCBbMCwxLDJdKSgpWzFdLCAzKTtcbiAgICB9KTtcblxuICAgIGl0KGB3b3JrcyB3aXRoIGluaXRpYWxpemVycyBpbiBmb3IgaW4gbG9vcHNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e29iajoge2RlY2w6IEZ1bmN0aW9ufX0+KGBcbiAgICAgICAgZXhwb3J0cy5iID0gWzAsMSwyXTtcbiAgICAgICAgZXhwb3J0cy5vYmogPSB7XG4gICAgICAgICAgZGVjbDogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHBvcnRzLmIpIGEgKz0gcHJvcDtcbiAgICAgICAgICAgIHByb3AgPSBcImhlbGxvXCI7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgcHJvcCBlc2NhcGVzLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgYCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUub2JqLmRlY2woXCJcIikoKSwgXCJoZWxsb1wiKTtcbiAgICB9KTtcblxuICAgIGl0KGB3b3JrcyB3aXRoIGNhdGNoIGNsYXVzZXNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e29iajoge2RlY2w6IEZ1bmN0aW9ufX0+KGBcbiAgICAgICAgdmFyIGVyciwgZTtcbiAgICAgICAgZXhwb3J0cy5vYmogPSB7XG4gICAgICAgICAgZGVjbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoXCJIZWxsb1wiKTsgfSBjYXRjaCAoZSkgeyBlcnIgPSBlOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgYCk7XG4gICAgICBtb2R1bGUub2JqLmRlY2woKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5vYmouZGVjbC5fX3Njb3BlX19bJ2VyciddLm1lc3NhZ2UsIFwiSGVsbG9cIik7XG4gICAgfSk7XG5cbiAgICBpdChgd29ya3Mgd2l0aCBvYmplY3QgbGl0ZXJhbHNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e29iajoge2RlY2w6IEZ1bmN0aW9ufX0+KGBcbiAgICAgICAgdmFyIGUgPSA1O1xuICAgICAgICBleHBvcnRzLm9iaiA9IHtcbiAgICAgICAgICBkZWNsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGU6IGUgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5vYmouZGVjbCgpLmUsIDUpO1xuICAgIH0pO1xuXG4gICAgaXQoYHdvcmtzIHdpdGggY29tcHV0ZWQgcHJvcGVydGllc2AsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdHJ1bWVudE1vZHVsZTx7b2JqOiB7ZGVjbDogRnVuY3Rpb259fT4oYFxuICAgICAgICB2YXIgZSA9IDA7XG4gICAgICAgIGV4cG9ydHMub2JqID0ge1xuICAgICAgICAgIGRlY2w6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1tlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5vYmouZGVjbCgxMDApLCAxMDApO1xuICAgIH0pO1xuXG4gICAgaXQoYHdvcmtzIHdpdGggbmFtZWQgZnVuY3Rpb24gZXhwcmVzc2lvbnNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e29iajoge2RlY2w6IEZ1bmN0aW9ufX0+KGBcbiAgICAgICAgdmFyIGUgPSAwO1xuICAgICAgICBleHBvcnRzLm9iaiA9IHtcbiAgICAgICAgICBkZWNsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBlKGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGkgPT09IDAgPyA1IDogZShpIC0gMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIGApO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLm9iai5kZWNsKCkoMyksIDUpO1xuICAgIH0pO1xuXG4gICAgaXQoYGRvZXMgbm90IGNoYW5nZSB2YWx1ZSBvZiB0aGlzYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtvYmo6IHtkZWNsOiBGdW5jdGlvbn19PihgXG4gICAgICAgIHZhciBlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuICAgICAgICBleHBvcnRzLm9iaiA9IHtcbiAgICAgICAgICBkZWNsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgYCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUub2JqLmRlY2woKSwgZ2xvYmFsKTtcbiAgICB9KTtcblxuICAgIGl0KGBrZWVwcyBzdHJpY3QgbW9kZSBkZWNsYXJhdGlvbmAsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdHJ1bWVudE1vZHVsZTx7b2JqOiB7ZGVjbDogRnVuY3Rpb259fT4oYFxuICAgICAgICB2YXIgZSA9IGZ1bmN0aW9uKCkgeyBcInVzZSBzdHJpY3RcIjsgcmV0dXJuIHRoaXM7IH07XG4gICAgICAgIGV4cG9ydHMub2JqID0ge1xuICAgICAgICAgIGRlY2w6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5vYmouZGVjbCgpLCB1bmRlZmluZWQpO1xuICAgIH0pO1xuXG4gICAgaXQoYHVwZGF0ZXMgYXJndW1lbnRzYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtvYmo6IHtkZWNsOiBGdW5jdGlvbn19PihgXG4gICAgICAgIGV4cG9ydHMub2JqID0ge1xuICAgICAgICAgIGRlY2w6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5vYmouZGVjbCgxMDApLCA0KTtcbiAgICB9KTtcblxuICAgIGl0KGB3b3JrcyBvbiBmdW5jdGlvbnMgaWxsZWdhbGx5IGRlZmluZWQgaW4gYmxvY2tzYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtvYmo6IHtkZWNsOiBGdW5jdGlvbn19PihgXG4gICAgICAgIGV4cG9ydHMub2JqID0ge1xuICAgICAgICAgIGRlY2w6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKDEpIHtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gWigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gYTsgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gWjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5vYmouZGVjbCgpKCkoKSwgNCk7XG4gICAgfSk7XG5cbiAgICBpdChgd29ya3Mgb24gZnVuY3Rpb25zIGlsbGVnYWxseSBkZWZpbmVkIGluIHN3aXRjaCBjYXNlc2AsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdHJ1bWVudE1vZHVsZTx7b2JqOiB7ZGVjbDogRnVuY3Rpb259fT4oYFxuICAgICAgICBleHBvcnRzLm9iaiA9IHtcbiAgICAgICAgICBkZWNsOiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFooKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYSA9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBhOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5vYmouZGVjbCgxKSgpKCksIDQpO1xuICAgIH0pO1xuXG4gICAgaXQoYHdvcmtzIG9uIGZ1bmN0aW9uIGV4cHJlc3Npb25zIHdpdGggbmFtZXNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e29iajogRnVuY3Rpb259PihgXG4gICAgICAgIGV4cG9ydHMub2JqID0gZnVuY3Rpb24gcygpIHtcbiAgICAgICAgICBzID0gNDtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgIGApO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLm9iaigpLCBtb2R1bGUub2JqKTtcbiAgICB9KTtcblxuICAgIGl0KGBtYWtlcyBwcm94eSBvYmplY3RzIGVxdWFsIHRvIG9yaWdpbmFsIG9iamVjdHNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e29iajogRnVuY3Rpb24sIGNtcDogKGE6IGFueSkgPT4gYm9vbGVhbn0+KGBcbiAgICAgICAgZ2xvYmFsLmEgPSB7fTtcbiAgICAgICAgZXhwb3J0cy5vYmogPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG4gICAgICAgIGV4cG9ydHMuY21wID0gZnVuY3Rpb24oYikge1xuICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICB9O1xuICAgICAgYCk7XG4gICAgICBjb25zdCBhID0gbW9kdWxlLm9iaigpO1xuICAgICAgKDxXaW5kb3c+IDxhbnk+IGdsb2JhbCkuJCQkSU5TVFJVTUVOVF9QQVRIUyQkJChbe1xuICAgICAgICBpZDogMSxcbiAgICAgICAgaXNHcm93aW5nOiB0cnVlLFxuICAgICAgICBpbmRleE9yTmFtZTogXCJhXCIsXG4gICAgICAgIHR5cGU6IFBhdGhTZWdtZW50VHlwZS5QUk9QRVJUWSxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9XSk7XG4gICAgICBhc3NlcnROb3RFcXVhbChtb2R1bGUub2JqKCksIGEsIGBQcm94eSBmb3IgZ2xvYmFsIHZhcmlhYmxlICdhJyBpcyBwcm9wZXJseSBpbnN0YWxsZWRgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5jbXAoYSksIHRydWUsIGBhID09PSBQcm94eShhKWApO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLmNtcChtb2R1bGUub2JqKCkpLCB0cnVlLCBgUHJveHkoYSkgPT09IFByb3h5KGEpYCk7XG4gICAgfSk7XG5cbiAgICBpdChgd29ya3Mgd2l0aCBudWxsIGFycmF5IGVudHJ5YCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtvYmo6IChudW1iZXIgfCBudWxsKVtdfT4oYGV4cG9ydHMub2JqID0gWywxLDJdO2ApO1xuICAgICAgYXNzZXJ0RXF1YWwobW9kdWxlLm9ialswXSwgbnVsbCk7XG4gICAgfSk7XG5cbiAgICBpdChgd29ya3Mgd2l0aCBjb21wdXRlZCBwcm9wZXJ0aWVzYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0cnVtZW50TW9kdWxlPHtmY246ICgpID0+IG51bWJlcn0+KGBcbiAgICAgICAgdmFyIGEgPSBcImhlbGxvXCI7XG4gICAgICAgIHZhciBvYmogPSB7IGhlbGxvOiAzIH07XG4gICAgICAgIGV4cG9ydHMuZmNuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialthXTtcbiAgICAgICAgfTtgKTtcblxuICAgICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuKCksIDMpO1xuICAgICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuLl9fc2NvcGVfXy5hLCBcImhlbGxvXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoYHdvcmtzIHdpdGggYXJndW1lbnRzIHRoYXQgZG8gbm90IGVzY2FwZWAsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdHJ1bWVudE1vZHVsZTx7ZmNuOiAoYTogbnVtYmVyKSA9PiBudW1iZXJ9PihgXG4gICAgICAgIGV4cG9ydHMuZmNuID0gZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHJldHVybiBhXG4gICAgICAgIH07YCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuKDMpLCAzKTtcbiAgICB9KTtcblxuICAgIGl0KGB3b3JrcyB3aXRoIGFyZ3VtZW50cyB0aGF0IGVzY2FwZWAsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdHJ1bWVudE1vZHVsZTx7ZmNuOiAoYTogbnVtYmVyKSA9PiAoKSA9PiBudW1iZXJ9PihgXG4gICAgICAgIGV4cG9ydHMuZmNuID0gZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGE7IH07XG4gICAgICAgIH07YCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuKDMpKCksIDMpO1xuICAgIH0pO1xuXG4gICAgaXQoYG1vdmVzIGFsbCBoZWFwIG9iamVjdHMgd2hlbiBldmFsIGlzIHVzZWRgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e2ZjbjogKGE6IHN0cmluZykgPT4gYW55fT4oYFxuICAgICAgICB2YXIgc2VjcmV0ID0gMztcbiAgICAgICAgZXhwb3J0cy5mY24gPSBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWwoYSk7XG4gICAgICAgIH07YCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuKFwic2VjcmV0XCIpLCAzKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5mY24uX19zY29wZV9fLnNlY3JldCwgMyk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuKFwiYVwiKSwgXCJhXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoYGFwcHJvcHJpYXRlbHkgb3ZlcndyaXRlcyB2YXJpYWJsZXMgd2hlbiBldmFsIGlzIHVzZWRgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IGluc3RydW1lbnRNb2R1bGU8e2ZjbjogKGE6IHN0cmluZykgPT4gYW55fT4oYFxuICAgICAgICBnbG9iYWwuc2VjcmV0ID0gMztcbiAgICAgICAgZXhwb3J0cy5mY24gPSBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWwoYSk7XG4gICAgICAgIH07YCk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuLl9fc2NvcGVfXy5zZWNyZXQsIDMpO1xuICAgICAgYXNzZXJ0RXF1YWwoKDxhbnk+IGdsb2JhbCkuc2VjcmV0LCAzKTtcbiAgICAgICg8YW55PiBnbG9iYWwpLnNlY3JldCA9IDQ7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuLl9fc2NvcGVfXy5zZWNyZXQsIDQpO1xuICAgICAgbW9kdWxlLmZjbihcInNlY3JldCA9IDZcIik7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuZmNuLl9fc2NvcGVfXy5zZWNyZXQsIDYpO1xuICAgICAgYXNzZXJ0RXF1YWwoKDxhbnk+IGdsb2JhbCkuc2VjcmV0LCA2KTtcbiAgICB9KTtcblxuICAgIGl0KGB3b3JrcyB3aXRoIHdpdGgoKWAsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gaW5zdHJ1bWVudE1vZHVsZTx7ZmNuOiAoKSA9PiBhbnksIGFzc2lnbjogKHY6IGFueSkgPT4gYW55fT4oYFxuICAgICAgICB2YXIgbCA9IDM7XG4gICAgICAgIHZhciBvID0geyBsOiA1IH07XG4gICAgICAgIGV4cG9ydHMuZmNuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd2l0aChvKSB7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24odikge1xuICAgICAgICAgIHdpdGgobykgeyBsID0gdjsgcmV0dXJuIGw7IH1cbiAgICAgICAgfTtgKTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5mY24oKSwgNSk7XG4gICAgICBhc3NlcnRFcXVhbChtb2R1bGUuYXNzaWduKDcpLCA3KTtcbiAgICAgIGFzc2VydEVxdWFsKG1vZHVsZS5mY24oKSwgNyk7XG4gICAgfSk7XG5cbiAgICAvLyBpbnN0cnVtZW50IGEgZ2xvYmFsIHZhcmlhYmxlIGFuZCBnZXQgc3RhY2sgdHJhY2VzXG4gICAgLy8gd2l0aCgpIHdpdGggdW5kZWZpbmVkIC8gbnVsbCAvIHplcm9pc2ggdmFsdWVzLlxuXG4gICAgLy8gZ3Jvd2luZyBwYXRoczogc2V0IHVwIHN1Y2ggdGhhdCBpdCBoYXMgdHdvIHNlcGFyYXRlIGN1c3RvbSBzZXR0ZXJzIVxuXG4gICAgLy8gZ3Jvd2luZyB3aW5kb3c/XG5cbiAgICAvLyBjeWNsZSBvZiBncm93aW5nIG9iamVjdHM/P1xuXG4gICAgLy8gZ2V0dGVycy9zZXR0ZXJzXG5cbiAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFsXG5cbiAgICAvLyBhcnJvdyBmdW5jdGlvbnMsIHdpdGggYHRoaXNgIGFzIHRoZSBsZWFraW5nIG9iamVjdC4gYXJyb3cgaGFzIG9ubHkgcmVmLlxuICAgIC8vIG11bHRpcGxlIG9iamVjdCBwYXR0ZXJucyB0aGF0IHJlZmVyZW5jZSBlYWNoIG90aGVyLCBlLmcuOlxuICAgIC8vIHZhciB7YSwgYiwgY30gPSBmb28sIHtkPWF9ID0gYmFyO1xuXG4gICAgLy8gYSBsZWFrIGluIGEgZ2V0dGVyLCBlLmcuIHsgZ2V0IGZvbygpIHsgdmFyIGE7ICByZXR1cm4gZnVuY3Rpb24oKSB7IH0gfX1cbiAgICAvLyBvciBhY3R1YWxseSBtb3JlIGxpa2UgeyBnZXQgZm9vKCkgeyBiYXJbcmFuZG9tXSA9IDM7IH19XG4gICAgLy8gPT0+IFNob3dzIHVwIGFzIGBnZXQgZm9vYCEhIEluc3RydW1lbnQgYm90aCBgZm9vYCBhbmQgYGdldCBmb29gLlxuICB9KTtcbiAgLy8gTkVFRCBBIFNXSVRDSCBDQVNFIFZFUlNJT04gd2hlcmUgaXQncyBub3Qgd2l0aGluIGEgYmxvY2shISFcbn0pOyJdfQ==